gcc prog.c						(compiles prog.c into exacutable a.out)
gcc -o progx prog.c					(compiles prog.c into executable progx)
gcc -g prog.c						(compiles source code in program.c to executable a.out with extra info for the debugger-adds a symbol table for debbuger to read)
objdump -D a.out					(dumping object file of execultable to assembly with addresses)
objdump -D M intel a.out				(disassembly of executable in Intel assembly language)
objdump -D a.out | grep -A20 main.			(disassembly of executable a.out greppin the start of main function)
gdb -q a.out						(debuger of program a.out in a quiet mode)
(gdb) run						(runs the program in debugger)
(gdb) break main					(sets the break point in the function main)
(gdb) info registers //i r				(show register values on the breakpoint)
(gdb) quit						(quit debugger)
(gdb) (registers) rax,rbx,rcx,rdx			(general purpose registers-Accumulator, Base, Counter, Data)
(gdb) (registers) rsp,rbp,rsi,rdi			(general purpose registers -POINTERS:Stack Pointer,Base Pointer,Source Index,Destination Index)
(gdb) (registers) rip					(instruction pointer)
(gdb) (registers) eflags				(flags used for comparisons and memory segmentation)
(gdb) info register rip // i r rip			(displays value of register rip at the breakpint)
(gdb) list						(lists the source code-only if compiled with -g to include the symbol table in executable)
(gdb) disassemble main					(disassemble the source code of function main into assembly)
(gdb) set disassembly intel/att				(sets default disassembly assembly type- intel or at&t)
(gdb) x 0x555555555149					(examine value on the memory address 0x555555555149)
(gdb) x/o 0x555555555149 //x/u x//t			(examine memory address and show value in octal/unsigned decimal or binary
(gdb) x $rip						(display value of the address that register RIP-instruction pointer register points to)
(gdb) x/12x $rip					(display value in the address register rip is pointing to and 11 consecutive values to it in hex)
(gdb) x/12xb $rip    //h/w/g				(diplay value in BYTES on the address stored in register rip, plus 11 consecutive BYTES, alternatives are halfword, word-default and giant)
(gdb) x/i $rip						(display instrction instead of a value)
(gdb) x/5i $rip						(display next 5 instructions starting with the value held in an address stored in RIP register)
(gdb) break *main+12					(set a breakpoint at the instruction 12 bytes from address of start of main function)
(gdb) print $rip					(saves the address stored in register rip to a variable $1-to $X)
(gdb) nexti						(executes next instruction)
(gdb) cont						(continues execution)
(gdb) bt						(shows backtrace of the stack)

