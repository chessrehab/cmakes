ASM COMPILE  nasm -f elf -g -F stabs filename.asm	compiling the asm source file
NASM COMPILE ld -o outputfile filename.o		linking the object file to output executable elf
NASM COMPILE ld -m elf_i386 -o outputfile filename.o	linking object file on 32 bit mode
NASM COMPILE nasm -f elf32 -g -F stabs filename.asm	compiling for 32 bit assembly
NASM COMPILE nasm -f -g -F stabs			-f (format of the file) -g (include debug info) -F (format of debug info stabs/dwarf)

OBJDUMP objdump -D executablefile			object dump in assembly of executablefile
OBJDUMP objdump -D executable | grep -A20 main		grep main function from dissasembled executable
OBJDUMP objdump --disassembler-options="intel"		intel syntax
OBJDUMP objdump -M intel				intel syntax

GDB gdb -q executablefile				quiet  mode
GDB break main						set the breakpoint to symbol <main>
GDB del break 1 (d br 1)				delete breakpoint
GDB info breakpoints (i br)				show active breakpoints
GDB info registers (i r)				show register values
GDB info var (i va)					info of data variables (symbols)
GDB x/xb &VAR						examine whats on the variable address
GDB run							run program
GDB cont						continue
GDB kill						kill debugged program
GDB quit						quit gdb
GDB set disassembly intel				set dissasembly mode
GDB list						list the source code
GDB list NR_LINE					list the source code from line NR_LINE
GDB disassemble _section				disasemble the named section
GDB i r eip						info register eip
GDB x/x $eip						eXamine contents(in heX) of memory stored in register eip
GDB x/t $reg						eXamine contents(in binary) on the address pointed to by register
GDB x/u $reg						eXamine contents(in unsigned int) on the address pointed to by register
GDB x/20xw ADDR						eXamine 20 words(4b) units of content (in heX) at address
GDB x/20xb ADDR						eXamine 20 bytes (in heX) at address
GDB x/20xg ADDR						eXamine 20 giants(8b) (in heX) at address
GDB x/20xh ADDR						eXamine 20 halfwords(2b) (in heX) at address
GDB x/i ADDR($reg)					eXamine instruction at address
GDB x/4i ADDR($reg)					eXamine 4 consecutive instructions at address
GDB print $reg-4					store address $reg-4 in $1
GDB nexti						next instruction exec
GDB x/cb ADDR						eXamine byte and display as char
GDB x/6cb ADDR						eXamine 6 chars starting at address
GDB x/s ADDR						eXamine a NUL terminated string starting at addr
GDB bt							backtrace the stack


NASM INSTR mov dest,source				copy value from source to destination
NASM INSTR mov dest,[source]				copy value pointed to by address source to dest
NASM INSTR mov [dest],source				copy source to memory address poinbted to by dest
NASM INSTR xchg dest,source				exchange values between source and destination
NASM INSTR inc dest					increment destination value by 1
NASM INSTR dec dest					decrement destination value by 1
NASM INSTR jmp	LABEL					jumps to label or address
NASM INSTR jnz LABEL					jump when zero flag is 0
NASM INSTR movsx dest, source				copy value with keeping the sign bit of destination (sign extend)
NASM INSTR movzx dest, source				copy value with replacing the rest of dest with zeros (zero extend)
NASM INSTR neg OPERAND					negate a operand(register,memory value)
NASM INSTR mul r/m8 (r/m16, r/m32)			unsigned multiply value stored in IMPLICIT al(ax,eax) by r/m8 (r16,r32), store result in ax(ax+dx,edx+eax) and CF(1) if carryover and then dx (edx)
NASM INSTR imul r/m8 (r/m16, r/m32)			signed multiply value stored in IMPLICIT al(ax,eax) by r/m8 (r16,r32), store result in ax(ax+dx,edx+eax) and CF(1) if carryover and then dx (edx)
NASM INSTR div r/m8 (r/m16, r/m32)			divide value stored in IMPLICIT al(ax, eax) by r/m8(r/m16,r/m32) store result in al(ax,eax) and remainder in ah (dx,edx)
NASM INSTR add r/m, value/r/m				add 1st operand to second and store result in 1st operand
NASM INSTR sub r/m, value				subtracts from first operand a value
NASM INSTR push r16-32/m16-32/v				push register or memory or value on the stack
NASM INSTR pop r/m					pops value from the stack to register/memory
NASM INSTR pushf					pushes the flags register on the stack
NASM INSTR popf						pops the flags register
NASM INSTR pushfd					pushes flags register on the stack
NASM INSTR popfd					pops the flags register
NASM INSTR pusha					push all 8 registers on the stack
NASM INSTR popa						pop all the 8 registers from the stack
NASM INSTR pushad					push all 8 registers on the stack
NASM INSTR popad					pop all 8 registers from the stack
NASM INSTR cmp DEST,SRC					compares two operands by substracting them
NASM INSTR and DEST,val					ands the destination=reg or memory, csnnot do 2 memories
NASM INSTR not DEST					nots the destination reg or mem
NASM INSTR or DEST,val					ors the destination with source
NASM INSTR xor DEST,val					xors the destination with val
NASM INSTR shr DEST,val					shifts right by val amount of bits
NASM INSTR shl DEST,val					shifts left by val amount of bits
NASM INSTR ja LABEL (jnbe)				jump if above to label (unsigned)
NASM INSTR jb LABEL (jnae)				jump if below to label (unsigned)
NASM INSTR jae LABEL (jnb)				jump above or equal to label (unsigned)
NASM INSTR jbe LABEL (jna)				jump bellow or equal to label (unsigned)
NASM INSTR je LABEL (jz)				jump if equal to label
NASM INSTR jne LABEL (jnz)				jump if not equal to label
NASM INSTR jg LABEL (jnle)				jump if greater to label (signed)
NASM INSTR jl LABEL (jnge)				jump if less to label (signed)
NASM INSTR jge LABEL (jnl)				jump if greater or equal to label (signed)
NASM INSTR jle LABEL (jng)				jump if less or equal to label (signed)
NASM INSTR jnc LABEL					jump if not CF
NASM INSTR jc LABEL					jump if CF to label
NASM INSTR ror DEST,val					rotate destination right
NASM INSTR rol DEST,val					rotate destination left by val
NASM INSTR rcr DEST,val					rotate destination right via the CF
NASM INSTR rcl DEST,val					rotate destination left via the CF by val
NASM INSTR test DEST,val				check one bit in dest via bit mask in val, ZF is set if bit is not set
NASM INSTR bt reg,bit_position				puts the bit from destination on bit_position to CF
NASM INSTR stc						set CF to 1
NASM INSTR clc						clear CF
NASM INSTR lea reg,[base+index *2,3,4,5,8,9+dispo]	load effective address to register based on eff. add. calculation with allowed values
NASM INSTR xlat						implicit takes the address of lookup table from ebp and offset from al and places the value from lkp back to al
NASM INSTR std						set direction flag to 1
NASM INSTR cld						clear DF to 0
NASM INSTR loop LABEL					decrease ecx and if its not zero jump to label
NASM INSTR stosb					store byte(from al) to address pointed to edi and increase(if DF=0) edi or decrease (if DF=1) edi by one byte
NASM INSTR rep stosb					store byte(from al) ECX number of times to address pointed to edi, while increasing (DF=0) or decreasing(DF=1) edi as well as decreasing ECX until ECX is 0
NASM INSTR movsb					store byte(from address pointed to by ESI) to address pointed to EDI and increase(if DF=0) EDI or decrease (if DF=1) EDI by one byte
NASM INSTR rep movsb					store byte(from address pointed to by ESI) ECX number of times to address pointed to EDI, while increasing (DF=0) or decreasing(DF=1) EDI as well as decreasing ECX until ECX is 0
NASM INSTR stosw					store word(from ax) to address pointed to edi and increase(if DF=0) edi or decrease (if DF=1) edi by one word
NASM INSTR rep stosw					store word(from ax) ECX number of times to address pointed to edi, while increasing (DF=0) or decreasing(DF=1) edi as well as decreasing ECX until ECX is 0
NASM INSTR movsw					store word(from address pointed to by ESI) to address pointed to EDI and increase(if DF=0) EDI or decrease (if DF=1) EDI by one word
NASM INSTR rep movsw					store word(from address pointed to by ESI) ECX number of times to address pointed to EDI, while increasing (DF=0) or decreasing(DF=1) EDI as well as decreasing ECX until ECX is 0
NASM INSTR stosd					store doubleword(from eax) to address pointed to edi and increase(if DF=0) edi or decrease (if DF=1) edi by one doubleword
NASM INSTR rep stosd					store doubleword(from eax) ECX number of times to address pointed to edi, while increasing (DF=0) or decreasing(DF=1) edi as well as decreasing ECX until ECX is 0
NASM INSTR movsd					store doubleword(from address pointed to by ESI) to address pointed to EDI and increase(if DF=0) EDI or decrease (if DF=1) EDI by one doubleword
NASM INSTR rep movsd					store doubleword(from address pointed to by ESI) ECX number of times to address pointed to EDI, while increasing (DF=0) or decreasing(DF=1) EDI as well as decreasing ECX until ECX is 0
NASM INSTR aaa						help adding in BCD arithmetic, clears out high nibble of al, basically stores decimal digits in 4bit nibbles, also using AF (auxiliary carry flag) to report carry overs






MASM 


SYSTEMCALLS NASM SYS_WRITE eax=4,ebx=fd,ecx=char*,edx=nr_char (INT 080h)	system write =write to standard output
SYSTEMCALLS NASM SYS_READ eax=3,ebx=fd,ecx=char*,edx=nr_chars (INT 080h)	system read=read from standard input(fd)
SYSTEMCALL NASM EXIT eax=1,ebx=return_val (INT 080h)				exit system call

